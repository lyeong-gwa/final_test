<meta charset="utf-8">
<p title=
"
1. 처리량
2. 응답시간
3. 경과시간
4. 자원 사용률
">
애플리케이션 성능 측정 지표<br>
1. 애플리케이션이 주어진시간에 처리할 수 있는 트랜잭션 수<br>
2. 사용자 입력이 끝난 후 애플리케이션의 응답 출력이 개시될 때까지의 시간<br>
3. 애플리케이션에 사용자가 요구를 입력한 시점부터 트랜잭션을 처리 후 그 결과의 출력이 완료할 때까지 걸리는 시간<br>
4. 애플리케이션이 트랜잭션을 처리하는 동안 사용하는 cpu, 메모리, 네트워크 사용량<br>

</p>

<p title=
"
1. 성능/부하/스트레스 점검 도구
2. 모니터링 도구
">
성능 분석 도구 유형<br>
1. 애플리케이션 성능 점검을 위해 가상의 사용자를 점검 도구 상에서 인위적으로 생성, 시스템 부아나 스트레스를 통해 점검하는 도구<br>
2. 애플리케이션 실행 시 자원 사용량을 확인하고 분석 가능한 도구<br>
</p>

<p title=
"
1. 데이터베이스 락
2. 불필요한 데이터베이스 패치
3. 연결누수
4. 부적절한 커넥션 풀 크기
">
데이터베이스 관련 성능 저하 원인<br>
1. 대량의 데이터 조회, 과도한 업데이터, 인덱스 생성시 발생하는 현상<br>
2. 실제 필요한 데이터보다 많은 대량의 데이터 요청이 들어올 경우 응답 시간 저하 현상 발생<br>
3. DB연결과 관련한 JDBC객체를 사용 후 종료하지 않을 경우 발생<br>
4. 너무 작거나 크게 설정한 경우 성능 저하 현상이 발생<br>
</p>

<p title=
"
소스 코드 최적화
">
읽기 쉽고 변경 및 추가가 쉬운 클린 코드를 작성하는 것
</p>

<p title=
"
베드 코드
">
개발자가 로직을 이해하기 어렵게 작성된 코드
</p>

<p title=
"
1. 외계인 코드
2. 스파게티 코드
3. 알수없는 변수명
4. 로직 중복
">
베드코드 종류<br>
1. 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 아주 어려운 코드<br>
2. 작동은 정상적으로 하지만 사람이 코드를 읽으면서 코드의 작도을 파악하기 어려운 코드<br>
3. 변수나 메서드에 대한 이름 정의를 알 수 없음<br>
4. 동일한 처리 로직이 중복되게 작성된 코드<br>
</p>

<p title=
"
1. 오염
2. 문서부족
3. 의미 없는 이름
4. 높은 결합도
5. 아키텍처 침식
">
베드 코드 유형
1. 비즈니스 기능을 수행하지 못하는 많은 컴포넌트 존재<br>
2. 현재 코드와 문서가 일치하지 않고 수정과 변경을 위한 도메인 지식은 크게 증가하지만 개발자의 지식부족 초래<br>
3. 함수, 클래스, 컴포넌트 이름들이 명확한 의미를 가지지 않음<br>
4. 클래스와 컴포넌트 간에 데이터와 컨트롤 흐름이 복잡하게 연결<br>
5. 아키텍처가 구별되지 않고 여러 솔루션으로 이루어져 아키텍처상 변형들로 인해 시스템 품질이 떨어짐<br>
</p>

<p title=
"
클린코드
">
잘 작성되어 가독성이 높고 단순하며 의존성을 줄이고 중복을 최소화하여 깔끔하게 잘 정리된 코드
</p>

<p title=
"
1.
2.
3.
4.
5.
">
클린코드 작성 원칙<br>
1. 이해하기 쉬운 용어 사용<br>
2. 한 번에 한 가지 처리만 수행<br>
3. 영향도를 최소화, 코드의 변경이 다른 부분에 영향이 없게 작성<br>
4. 중복된 코드를 제거, 공통된 코드를 사용<br>
5. 클래스/메서드/함수에 대해 동일한 수준의 추상화 구현, 상세 내용은 하위 클래스/메서드/함수에서 구현<br>
</p>

<p title=
"
리팩토링
">
유지보수 생산성 향상을 목적으로 기능을 변경하지 않고 복잡한 소스 코드를 수정, 보완하여 가용성 및 가독성을 높이는 기법
</p>

<p title=
"
1. 유지보수성 향상
2. 유연한 시스템
3. 생산성 향상
4. 품질 향상
">
리팩토링 목적<br>
1. 복잡한 코드의 단순화, 소스의 가독성 향상<br>
2. 소프트웨어 요구사항 변경에 유연한 대응<br>
3. 정제 및 최적화된 소스의 재사용<br>
4. 소프트웨어 오류발견이 용이하여 품질 향상<br>
</p>
